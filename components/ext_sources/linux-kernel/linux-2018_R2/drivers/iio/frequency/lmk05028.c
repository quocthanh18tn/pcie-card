
#include <linux/device.h>
#include <linux/err.h>
#include <linux/i2c.h>
#include <linux/interrupt.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/regulator/consumer.h>
#include <linux/slab.h>
#include <linux/sysfs.h>
#include <linux/uaccess.h>
#include <linux/delay.h>

#include <linux/iio/iio.h>
#include <linux/iio/sysfs.h>
#include <linux/iio/events.h>
#include <linux/of_gpio.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h>

#define LMK05028_NUM_CHAN 5
static int lmk05028_conf_reg(struct iio_dev *indio_dev);

unsigned int lmk_reg[] = {
 0x00C ,0x00C ,0x000 ,0x001 ,0x002 ,0x003 ,0x004 ,0x005 ,0x006 ,0x007 ,0x008 ,0x009 ,0x00A ,0x00B ,0x00C ,0x00D ,0x00E ,0x00F ,0x010 ,0x011 ,0x012 ,0x013 ,0x014 ,0x015 ,0x016 ,0x017 ,0x018 ,0x019 ,0x01A ,0x01B ,0x01C ,0x01D ,0x01E ,0x01F ,0x020 ,0x021 ,0x022 ,0x023 ,0x024 ,0x025 ,0x026 ,0x027 ,0x028 ,0x029 ,0x02A ,0x02B ,0x02C ,0x02D ,0x02E ,0x02F ,0x030 ,0x031 ,0x032 ,0x033 ,0x034 ,0x035 ,0x036 ,0x037 ,0x038 ,0x039 ,0x03A ,0x03B ,0x03C ,0x03D ,0x03E ,0x03F ,0x040 ,0x041 ,0x042 ,0x043 ,0x044 ,0x045 ,0x046 ,0x047 ,0x048 ,0x049 ,0x04A ,0x04B ,0x04C ,0x04D ,0x04E ,0x04F ,0x050 ,0x051 ,0x052 ,0x053 ,0x054 ,0x055 ,0x056 ,0x057 ,0x058 ,0x059 ,0x05A ,0x05B ,0x05C ,0x05D ,0x05E ,0x05F ,0x060 ,0x061 ,0x062 ,0x063 ,0x064 ,0x065 ,0x066 ,0x067 ,0x068 ,0x069 ,0x06A ,0x06B ,0x06C ,0x06D ,0x06E ,0x06F ,0x070 ,0x071 ,0x072 ,0x073 ,0x074 ,0x075 ,0x076 ,0x077 ,0x078 ,0x079 ,0x07A ,0x07B ,0x07C ,0x07D ,0x07E ,0x07F ,0x080 ,0x081 ,0x082 ,0x083 ,0x084 ,0x085 ,0x086 ,0x087 ,0x088 ,0x089 ,0x08A ,0x08B ,0x08C ,0x08D ,0x08E ,0x08F ,0x090 ,0x091 ,0x092 ,0x093 ,0x094 ,0x095 ,0x096 ,0x097 ,0x098 ,0x099 ,0x09A ,0x09B ,0x09C ,0x09D ,0x09E ,0x09F ,0x0A0 ,0x0A1 ,0x0A2 ,0x0A3 ,0x0A4 ,0x0A5 ,0x0A6 ,0x0A7 ,0x0A8 ,0x0A9 ,0x0AA ,0x0AB ,0x0AC ,0x0AD ,0x0AE ,0x0AF ,0x0B0 ,0x0B1 ,0x0B2 ,0x0B3 ,0x0B4 ,0x0B5 ,0x0B6 ,0x0B7 ,0x0B8 ,0x0B9 ,0x0BA ,0x0BB ,0x0BC ,0x0BD ,0x0BE ,0x0BF ,0x0C0 ,0x0C1 ,0x0C2 ,0x0C3 ,0x0C4 ,0x0C5 ,0x0C6 ,0x0C7 ,0x0C8 ,0x0C9 ,0x0CA ,0x0CB ,0x0CC ,0x0CD ,0x0CE ,0x0CF ,0x0D0 ,0x0D1 ,0x0D2 ,0x0D3 ,0x0D4 ,0x0D5 ,0x0D6 ,0x0D7 ,0x0D8 ,0x0D9 ,0x0DA ,0x0DB ,0x0DC ,0x0DD ,0x0DE ,0x0DF ,0x0E0 ,0x0E1 ,0x0E2 ,0x0E3 ,0x0E4 ,0x0E5 ,0x0E6 ,0x0E7 ,0x0E8 ,0x0E9 ,0x0EA ,0x0EB ,0x0EC ,0x0ED ,0x0EE ,0x0EF ,0x0F0 ,0x0F1 ,0x0F2 ,0x0F3 ,0x0F4 ,0x0F5 ,0x0F6 ,0x0F7 ,0x0F8 ,0x0F9 ,0x0FA ,0x0FB ,0x0FC ,0x0FD ,0x0FE ,0x0FF ,0x100 ,0x101 ,0x102 ,0x103 ,0x104 ,0x105 ,0x106 ,0x107 ,0x108 ,0x109 ,0x10A ,0x10B ,0x10C ,0x10D ,0x10E ,0x10F ,0x110 ,0x111 ,0x112 ,0x113 ,0x114 ,0x115 ,0x116 ,0x117 ,0x118 ,0x119 ,0x11A ,0x11B ,0x11C ,0x11D ,0x11E ,0x11F ,0x120 ,0x121 ,0x122 ,0x123 ,0x124 ,0x125 ,0x126 ,0x127 ,0x128 ,0x129 ,0x12A ,0x12B ,0x12C ,0x12D ,0x12E ,0x12F ,0x130 ,0x131 ,0x132 ,0x133 ,0x134 ,0x135 ,0x136 ,0x137 ,0x138 ,0x139 ,0x13A ,0x13B ,0x13C ,0x13D ,0x13E ,0x13F ,0x140 ,0x141 ,0x142 ,0x143 ,0x144 ,0x145 ,0x146 ,0x147 ,0x148 ,0x149 ,0x14A ,0x14B ,0x14C ,0x14D ,0x14E ,0x14F ,0x150 ,0x151 ,0x152 ,0x153 ,0x154 ,0x155 ,0x156 ,0x157 ,0x158 ,0x159 ,0x15A ,0x15B ,0x15C ,0x15D ,0x15E ,0x15F ,0x160 ,0x161 ,0x162 ,0x163 ,0x164 ,0x165 ,0x166 ,0x167 ,0x168 ,0x169 ,0x16A ,0x16B ,0x16C ,0x16D ,0x16E ,0x16F ,0x170 ,0x171 ,0x172 ,0x173 ,0x174 ,0x175 ,0x176 ,0x177 ,0x178 ,0x179 ,0x17A ,0x17B ,0x17C ,0x17D ,0x17E ,0x17F ,0x180 ,0x181 ,0x182 ,0x183 ,0x184 ,0x185 ,0x186 ,0x187 ,0x188 ,0x189 ,0x18A ,0x18B ,0x18C ,0x18D ,0x18E ,0x18F ,0x190 ,0x191 ,0x192 ,0x193 ,0x194 ,0x195 ,0x196 ,0x197 ,0x198 ,0x199 ,0x19A ,0x19B ,0x19C ,0x19D ,0x19E ,0x19F ,0x1A0 ,0x1A1 ,0x1A2 ,0x1A3 ,0x1A4 ,0x1A5 ,0x1A6 ,0x1A7 ,0x1A8 ,0x1A9 ,0x1AA ,0x1AB ,0x1AC ,0x1AD ,0x1AE ,0x1AF ,0x1B0 ,0x1B1 ,0x1B2 ,0x1B3 ,0x1B4 ,0x1B5 ,0x1B6 ,0x1B7 ,0x1B8 ,0x1B9 ,0x1BA ,0x1BB ,0x1BC ,0x1BD ,0x1BE ,0x1BF ,0x1C0 ,0x1C1 ,0x1C2 ,0x1C3 ,0x1C4 ,0x1C5 ,0x1C6 ,0x1C7 ,0x1C8 ,0x1C9 ,0x1CA ,0x1CB ,0x1CC ,0x1CD ,0x1CE ,0x1CF ,0x1D0 ,0x1D1 ,0x1D2 ,0x1D3 ,0x1D4 ,0x1D5 ,0x1D6 ,0x1D7 ,0x1D8 ,0x1D9 ,0x1DA ,0x1DB ,0x1DC ,0x1DD ,0x1DE ,0x1DF ,0x1E0 ,0x1E1 ,0x1E2 ,0x1E3 ,0x1E4 ,0x1E5 ,0x1E6 ,0x1E7 ,0x1E8 ,0x1E9 ,0x1EA ,0x1EB ,0x1EC ,0x1ED ,0x1EE ,0x1EF ,0x1F0 ,0x1F1 ,0x1F2 ,0x1F3 ,0x1F4 ,0x1F5 ,0x1F6 ,0x1F7 ,0x1F8 ,0x1F9 ,0x1FA ,0x1FB ,0x1FC ,0x1FD ,0x1FE ,0x1FF ,0x200 ,0x201 ,0x202 ,0x203 ,0x204 ,0x205 ,0x206 ,0x207 ,0x208 ,0x209 ,0x20A ,0x20B ,0x20C ,0x20D ,0x20E ,0x20F ,0x210 ,0x211 ,0x212 ,0x213 ,0x214 ,0x215 ,0x216 ,0x217 ,0x218 ,0x219 ,0x21A ,0x21B ,0x21C ,0x21D ,0x21E ,0x21F ,0x220 ,0x221 ,0x222 ,0x223 ,0x224 ,0x225 ,0x226 ,0x227 ,0x228 ,0x229 ,0x22A ,0x22B ,0x22C ,0x22D ,0x22E ,0x22F ,0x230 ,0x231 ,0x232 ,0x233 ,0x234 ,0x235 ,0x236 ,0x237 ,0x238 ,0x239 ,0x23A ,0x23B ,0x23C ,0x23D ,0x23E ,0x23F ,0x240 ,0x241 ,0x242 ,0x243 ,0x244 ,0x245 ,0x246 ,0x247 ,0x248 ,0x249 ,0x24A ,0x24B ,0x24C ,0x24D ,0x24E ,0x24F ,0x250 ,0x251 ,0x252 ,0x253 ,0x254 ,0x255 ,0x256 ,0x257 ,0x258 ,0x259 ,0x25A ,0x25B ,0x25C ,0x25D ,0x25E ,0x25F ,0x260 ,0x261 ,0x262 ,0x263 ,0x264 ,0x265 ,0x266 ,0x267 ,0x268 ,0x269 ,0x26A ,0x26B ,0x26C ,0x26D ,0x26E ,0x26F ,0x270 ,0x271 ,0x272 ,0x273 ,0x274 ,0x275 ,0x276 ,0x277 ,0x278 ,0x279 ,0x27A ,0x27B ,0x27C ,0x27D ,0x27E ,0x27F ,0x280 ,0x281 ,0x282 ,0x283 ,0x284 ,0x285 ,0x286 ,0x287 ,0x00C ,0x00C


}; 

unsigned int lmk_reg_data[] = {
  0x9A ,0x1A ,0x10 ,0x0B ,0x35 ,0x01 ,0x00 ,0x80 ,0x20 ,0x08 ,0x02 ,0x00 ,0x80 ,0x08 ,0x3B ,0x00 ,0x00 ,0x10 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0F ,0x55 ,0x55 ,0x00 ,0x00 ,0x00 ,0x00 ,0x05 ,0x05 ,0x34 ,0x03 ,0x00 ,0x10 ,0x02 ,0xCE ,0x00 ,0xBF ,0x06 ,0x83 ,0x18 ,0x05 ,0x0E ,0x08 ,0x6A ,0x00 ,0x00 ,0x10 ,0x00 ,0x00 ,0x00 ,0x00 ,0x05 ,0x10 ,0x00 ,0x00 ,0x08 ,0x00 ,0x00 ,0x20 ,0x00 ,0x06 ,0x00 ,0x10 ,0x10 ,0x00 ,0x0A ,0x10 ,0x20 ,0x00 ,0x06 ,0x3C ,0x02 ,0x00 ,0x00 ,0x00 ,0x06 ,0x5A ,0x00 ,0x00 ,0x12 ,0x12 ,0x12 ,0x3F ,0x00 ,0x02 ,0x03 ,0x43 ,0x0F ,0x17 ,0x05 ,0x02 ,0x03 ,0x33 ,0x0F ,0x17 ,0x05 ,0x00 ,0x34 ,0x15 ,0x55 ,0x55 ,0x55 ,0x55 ,0x03 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x02 ,0x00 ,0x01 ,0x01 ,0x77 ,0x00 ,0x3D ,0x70 ,0xA3 ,0xD7 ,0x0A ,0x3D ,0x03 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x02 ,0x00 ,0x01 ,0x01 ,0x77 ,0x00 ,0x00 ,0x03 ,0x0D ,0x29 ,0x00 ,0x0D ,0x29 ,0x24 ,0x01 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x09 ,0xA3 ,0x92 ,0xDB ,0xEA ,0x29 ,0x33 ,0x51 ,0xF0 ,0x00 ,0x11 ,0x95 ,0x15 ,0x09 ,0x19 ,0x09 ,0x09 ,0x00 ,0x00 ,0x2C ,0x00 ,0x00 ,0x2B ,0x00 ,0x00 ,0x1C ,0x00 ,0x00 ,0x1C ,0x00 ,0x00 ,0x00 ,0x26 ,0x00 ,0x00 ,0x25 ,0x00 ,0x00 ,0x16 ,0x00 ,0x00 ,0x16 ,0x00 ,0x02 ,0x26 ,0x02 ,0x58 ,0x01 ,0xF4 ,0x03 ,0xE8 ,0x02 ,0x26 ,0x02 ,0x58 ,0x02 ,0x26 ,0x02 ,0x58 ,0x00 ,0x00 ,0xEA ,0x60 ,0x00 ,0x00 ,0x98 ,0x96 ,0x80 ,0x00 ,0xEA ,0x60 ,0x00 ,0x00 ,0x98 ,0x96 ,0x80 ,0x00 ,0x4F ,0x79 ,0x0E ,0x00 ,0x98 ,0x96 ,0x81 ,0x01 ,0x7D ,0x78 ,0x40 ,0x00 ,0x98 ,0x96 ,0x80 ,0x0D ,0x10 ,0x0E ,0x0A ,0x00 ,0x98 ,0x96 ,0x80 ,0x00 ,0x98 ,0x96 ,0x80 ,0x00 ,0x98 ,0x96 ,0x80 ,0x00 ,0x00 ,0x00 ,0x00 ,0x3F ,0x1E ,0x3F ,0x00 ,0x10 ,0x80 ,0x00 ,0x00 ,0x07 ,0x10 ,0x80 ,0x00 ,0x00 ,0x07 ,0x0F ,0x0A ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x06 ,0x8B ,0x00 ,0x00 ,0x00 ,0x28 ,0xB0 ,0xA0 ,0x04 ,0x00 ,0x03 ,0xF5 ,0x00 ,0x00 ,0x00 ,0x1C ,0x00 ,0x00 ,0x02 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xA1 ,0x00 ,0xA1 ,0x03 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0D ,0x01 ,0x04 ,0x01 ,0x00 ,0x1E ,0x30 ,0x02 ,0x0F ,0x04 ,0x61 ,0xF8 ,0x43 ,0xC3 ,0xC3 ,0xC3 ,0xC3 ,0xC3 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x24 ,0x00 ,0x0A ,0x00 ,0x00 ,0x00 ,0x01 ,0x06 ,0x35 ,0x75 ,0x0B ,0x00 ,0x14 ,0x00 ,0x00 ,0x00 ,0x01 ,0x06 ,0x35 ,0x75 ,0x0B ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x02 ,0x00 ,0x03 ,0xE8 ,0x8C ,0x50 ,0x01 ,0x02 ,0x6C ,0x00 ,0x00 ,0x0E ,0x0F ,0x04 ,0x08 ,0x0B ,0x0A ,0x08 ,0x08 ,0x00 ,0x78 ,0x00 ,0x00 ,0x0E ,0x0C ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x3E ,0x80 ,0x00 ,0x00 ,0x00 ,0x00 ,0x24 ,0x0F ,0x0A ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x06 ,0x8B ,0x00 ,0x00 ,0x00 ,0x30 ,0x00 ,0xC0 ,0x07 ,0x00 ,0x02 ,0x17 ,0x00 ,0x00 ,0x00 ,0x16 ,0x1E ,0x1B ,0x02 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x62 ,0x00 ,0xE1 ,0x03 ,0x21 ,0x00 ,0x00 ,0x00 ,0x00 ,0x12 ,0x02 ,0x08 ,0x01 ,0x00 ,0x23 ,0x35 ,0x02 ,0x0F ,0x05 ,0x2B ,0x87 ,0x87 ,0x87 ,0x87 ,0x87 ,0x87 ,0x87 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x24 ,0x00 ,0x0A ,0x00 ,0x00 ,0x00 ,0x01 ,0x07 ,0x53 ,0x00 ,0x00 ,0x00 ,0x14 ,0x00 ,0x00 ,0x00 ,0x01 ,0x07 ,0x53 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x02 ,0x00 ,0x04 ,0x9B ,0x0F ,0x60 ,0x01 ,0x02 ,0x6C ,0x00 ,0x00 ,0x0E ,0x0F ,0x04 ,0x08 ,0x0B ,0x0A ,0x08 ,0x08 ,0x03 ,0xB5 ,0x00 ,0x00 ,0x0E ,0x0C ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x49 ,0xBA ,0x5E ,0x35 ,0x3F ,0x7D ,0x24 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x2C ,0xC4 ,0x55 ,0x4C ,0x49 ,0x49 ,0x82 ,0x2D ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xC0 ,0x44 ,0x16 ,0x0E ,0x83 ,0x10 ,0x0C ,0x09 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x95 ,0x01 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x95 ,0x01 ,0x00 ,0x00 ,0x00 ,0x01 ,0xBB ,0x3B

 }; 
enum lmk05028_iio_dev_attr {
	LMK05028_RESET,
};

struct gpio_desc	*reset_lmk;

struct lmk05028 {
	struct i2c_client	*client;
	unsigned int 	num_channels;
	unsigned int rst;
	struct iio_chan_spec	iio_channels[LMK05028_NUM_CHAN];

	/*
	 * DMA (thus cache coherency maintenance) requires the
	 * transfer buffers to live in their own cache lines.
	 */
	unsigned char		data[4] ____cacheline_aligned;
};

static int lmk05028_write(struct iio_dev *indio_dev, unsigned addr, unsigned val)
{
	int ret;

	struct lmk05028 *lmk = iio_priv(indio_dev);
	lmk->data[0] = (addr >> 8) & 0xFF;
	lmk->data[1] = addr & 0xFF;
	lmk->data[2] = val & 0xFF;

	ret = i2c_master_send(lmk->client, lmk->data, sizeof(lmk->data));
	if(ret < 0) {
		printk("Failed to write %s\n", indio_dev->name);
		return ret;
	}

	return 0;
}

static int lmk05028_read(struct iio_dev *indio_dev, unsigned addr)
{
	struct lmk05028 *lmk = iio_priv(indio_dev);
	int ret;

	unsigned char tx_buf[2], rx_buf;
	tx_buf[0] = ((addr >> 8) & 0xFF);
	tx_buf[1] = addr & 0xFF;
	memset(&rx_buf, 0, 1);

	ret = i2c_master_send(lmk->client, tx_buf, sizeof(tx_buf));
	if(ret < 0) {
		pr_info("Failed to read step 1 %s\n", indio_dev->name);
		return -1;
	}
	i2c_master_recv(lmk->client, &rx_buf, 1);
	if(ret < 0) {
		pr_info("Failed to read step 2 %s\n", indio_dev->name);
		return -1;
	}

	return rx_buf;
}
static int lmk05028_reg_access(struct iio_dev *indio_dev,
					unsigned reg, unsigned writeval, 
					unsigned *readval)
{
	int ret;
	mutex_lock(&indio_dev->mlock);
	if (readval == NULL) {
		lmk05028_write(indio_dev, reg, writeval);
		ret = 0;
	} else {
		*readval = lmk05028_read(indio_dev, reg);
		ret = 0;
	}

	mutex_unlock(&indio_dev->mlock);

	return ret;
}

static int lmk05028_read_raw(struct iio_dev *indio_dev,
			    struct iio_chan_spec const *chan,
			    int *val,
			    int *val2,
			    long mask)
{
	struct lmk05028 *lmk = iio_priv(indio_dev);
	// struct lmk05028_chan_spec *ch;

	// if (chan->address >= lmk->num_channels)
	// 	return -EINVAL;

	switch (mask) {
	case IIO_CHAN_INFO_FREQUENCY:
		*val = lmk->rst;
		return IIO_VAL_INT;
	default:
		return -EINVAL;
	}
};

static int lmk05028_write_raw(struct iio_dev *indio_dev,
			     struct iio_chan_spec const *chan,
			     int val,
			     int val2,
			     long mask)
{
	struct lmk05028 *lmk = iio_priv(indio_dev);
	// struct hmc7044_chan_spec *ch;

	// if (chan->address >= lmk->num_channels)
	// 	return -EINVAL;

	switch (mask) {
	case IIO_CHAN_INFO_FREQUENCY:
		// ch->divider = hmc7044_calc_out_div(hmc->pll2_freq, val);
		lmk->rst = val;
		mutex_lock(&indio_dev->mlock);
		if (lmk->rst == 1){
			lmk05028_conf_reg(indio_dev);
			pr_notice("Reset lmk\n");
		}
		mutex_unlock(&indio_dev->mlock);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int lmk05028_conf_reg(struct iio_dev *indio_dev)
{
	unsigned int i;
	for (i = 0; i < 682; i++) {
		lmk05028_write(indio_dev, lmk_reg[i], lmk_reg_data[i]);		
	}
	return 0;
}

static int lmk05028_setup(struct iio_dev *indio_dev)
{
	struct lmk05028 *lmk = iio_priv(indio_dev);
	unsigned int i;
	int ret;
	ret = lmk05028_conf_reg(indio_dev);
	if (ret < 0)
		return ret;

	printk("lmk_setup done\n");

	return 0;
}

static ssize_t lmk05028_store(struct device *dev,
				  struct device_attribute *attr,
				  const char *buf, size_t len)
{
	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
	struct lmk05028 *lmk = iio_priv(indio_dev);
	bool state = 0;
	int ret = 0;

	ret = strtobool(buf, &state);
	if (ret < 0)
		return ret;

	if (!state)
		return 0;

	mutex_lock(&indio_dev->mlock);
	switch ((u32)this_attr->address & 0xFF) {
	case 0:
		lmk05028_conf_reg(indio_dev);
		break;
	default:
		ret = -EINVAL;
	}
	mutex_unlock(&indio_dev->mlock);

	return ret ? ret : len;
}

static IIO_DEVICE_ATTR(reset, S_IRUGO | S_IWUSR ,
		      	NULL,
		       	lmk05028_store,
		       	0);

static struct attribute *lmk05028_attrs[] = {
	&iio_dev_attr_reset.dev_attr.attr,
	NULL,
};

static const struct attribute_group lmk05028_attrs_group = {
	.attrs = lmk05028_attrs,
};

static const struct iio_info lmk05028_iio_info = {
	.attrs = &lmk05028_attrs_group,
	.read_raw = &lmk05028_read_raw,
	.write_raw = &lmk05028_write_raw,
	.debugfs_reg_access = &lmk05028_reg_access,
	.driver_module = THIS_MODULE,
};

static int lmk05028_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	pr_info("thanhpq7 LMK\n");
	struct iio_dev *indio_dev;
	struct lmk05028 *lmk;
	int ret;
	int ret_export = 0;

	printk("Probing device %s\n", client->dev.of_node->name);

	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*lmk));
	if (indio_dev == NULL)
		return -ENOMEM;

	lmk = iio_priv(indio_dev);
	reset_lmk = devm_gpiod_get(&client->dev, "reset", GPIOD_OUT_HIGH);

	if(reset_lmk){
		ret_export = gpiod_export(reset_lmk,false);
		if(ret_export<0){
			pr_notice("Export reset_lmk pin failed with ret = %d", ret_export);
		}
		else{
			pr_notice("Export reset_lmk pin successfully\n");
		}
	}
	else{
		pr_notice("Descriptor of reset_lmk pin is NULL\n");
	}

	i2c_set_clientdata(client, indio_dev);
	lmk->client = client;
	lmk->rst = 0;
	// lmk->num_channels = 5;

	indio_dev->dev.parent = &client->dev;
	indio_dev->name = client->dev.of_node->name;
	
	indio_dev->info = &lmk05028_iio_info;
	indio_dev->modes = INDIO_DIRECT_MODE;
	// indio_dev->channels = lmk->iio_channels;
	// indio_dev->num_channels = lmk->num_channels;

	ret = lmk05028_setup(indio_dev);
	if(ret)
		return ret;

	ret = iio_device_register(indio_dev);
	if(ret)
		return ret;

	return 0;
}

static int lmk05028_remove(struct i2c_client *client)
{
	struct iio_dev *indio_dev = i2c_get_clientdata(client);
	struct lmk05028 *lmk = iio_priv(indio_dev);

	pr_info("Remove device LMK05028");

	iio_device_unregister(indio_dev);

	return 0;
}


static const struct i2c_device_id lmk05028_id[] = {
	{"lmk05028", 0},
	{/* NULL */}
};
MODULE_DEVICE_TABLE(i2c, lmk05028_id);


static struct i2c_driver lmk05028_driver = {
	.driver = {
		.name = "lmk05028",
		.owner = THIS_MODULE,
	},
	.probe = lmk05028_probe,
	.remove = lmk05028_remove,
	.id_table = lmk05028_id,
};

module_i2c_driver(lmk05028_driver);

MODULE_AUTHOR("NGUYEN THAC TOAN <toannt27@viettel.com.vn>");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("lmk05028 device driver");